工具箱
    原则
        高层抽象依赖高层抽象，而不依赖具体类
    模式
        工厂模式: 定义一个创建 一个 product 函数/~接口 abstract create() 由子类决定具体实例
        抽象工厂模式: 定义一个创建 多个 product 接口 implement interface
                    内含多个 abstract create()
                    并且 creator 存在形式 由 继承(作为主类的实例方法) 改为了 组合(外部类)
                        主类的一部分/工厂方法 --> 与主类完全对等的独立类/工厂类
        要点:
            1.所有的 工厂 都用来对 new 过程的封装
            2.简单工厂方法 = 简单代码重构 来 应对简单情景
            3.所有的 工厂 都是将 依赖具体类 改为 依赖高层抽象 达到松耦合
            4.工厂模式 将 实例化推迟到了 子类实现
            5.工厂 & 背后的依赖倒置原则 令 我们 针对抽象编程 而不是 针对具体类编程

避免违反 依赖倒置原则
    1.create 方法返回的变量不持有具体类的引用 而是抽象父类
    2.不要让类派生自具体类
    3.不要覆盖基类中已实现的方法

抽象工厂方法 & 工厂方法
    工厂方法 = extend + abstract new 方法
    抽象工厂方法 = implement + 组合成员变量 + 构造器传入赋值
    ------
    工厂方法 create 单个 Product 1-1
    抽象工厂方法 create 多个 Product 1-n [工厂方法的复杂版]
    ------
    二者说白了就是: 解耦 new 行为的 两种方法，看 creator 与 product 二者数量关系
        Product.length > 1 用 抽象工厂方法 | = 1 用 工厂方法就行
    ①抽象主类+子类继承覆写
    ②接口+接口实现类+接口类作为(抽象主类的)子类成员变量+接口类作为子类构造器参数