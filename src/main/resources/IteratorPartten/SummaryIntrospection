迭代器模式
    实质: 提供统一通用一种方法 顺序访问一个聚合对象中的各个元素，而又无需暴露其内部实现的一种方法
    使用场景: 每一种集合都有各自适合使用的时机，但如果仅仅是遍历内部数据，就没有必要让客户看到各个集合的内部实现，从而迭代器接口出现了
    好处: 客户无需强耦合集合的内部实现方法，只需要 通过 iterator hasNext next 这种简单统一通用的方法 就可以在元素间游走
        客户 <-- 迭代器 -- 集合 各司其职，三者代码更加高内聚，客户类与集合类 低耦合

    原则:
        单一责任: 一个类 应该 只有 一个引起 变化的原因
            开闭原则: 面向新增开放，面向修改关闭 => 避免类的改变，因为修改代码很容易造成潜在的错误
            当 一个类 具有 2个及以上 变化因素，则使得 将来这个类的变化几率急剧上升
            我们应当 只将 一个责任 指派给一个类
            当然 听起来是很容易的，但我们的大脑很习惯看着一大群行为，然后将它们集中在一个类中，尽管它们可能属于多个不同的责任
            成功的方法只有一个 -- 不懈努力检查你的设计，随着系统成长，随时观察有没有迹象显示某个类的改变因素超过一个

    注意:
        1.内部迭代器 Or 外部迭代器
            内部迭代器 只允许 客户 传入一个操作，客户无法控制遍历元素的过程，所以 内部迭代器更加没有弹性，但也有人认为这更加简单易用
            案例中实现的都是 外部迭代器
        2.前向 Or 后向遍历 迭代器
            java.util.ListIterator 接口 允许程序员 实现前向及后向遍历。
        3.迭代器取出的元素顺序 不能被保证是 具有大小次序的
        4.内聚 = 度量一个类 或 模块 紧密达到单一目的或责任的程度。高内聚 = 一个模块/类被设计成 只支持一组相关功能，反之为低内聚
            高内聚的代码 更容易维护