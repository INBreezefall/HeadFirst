适配器模式
    实质: CommandPattern 简化版，核心是相同的，均是 implement 某个接口 + 内置本体实例变量
    使用场景: 将一个类的接口 转换为 客户期望的另一个接口，适配器/中间层让 两个接口不同的类 可以合作无间
    注意
        1.现实远远复杂，不限制 只 包装一个 本体
        2.现实远远复杂，可以使用 extends 替换 implement 这个情况下 我们叫他 (继承)类适配器，反之叫做 (组合)对象适配器
            二者各有优劣，看成本情况进行综合考虑
    与命令模式异同
        同: 使用/调用者(Invoker) 与 被适配者(本体) 相互解耦 通过 中间/适配层
        异: Command 接口是 新的统一性的非已有的，而 这里的适配器 implement 的接口 是 已有目标的
            实质上就是 面向的场景不同 实现的 接口 具有不同的含义

外观模式
    实质: 封装 & 解耦 调用者 与 复杂底层系统
    使用场景: 提供一个统一高层次接口来屏蔽底层子系统的 n 个接口调用，让调用者 更加容易使用 底层系统的复杂调用

    原则: 最少知识
        减少对象之间的不必要交互，只留下关系最紧密的对象 [让我们的朋友圈维持在最小状态]
        好处: 不让太多的类耦合在一起，从而避免修改一部分类影响到很多其他类
        坏处: 创造更多的包装类，导致复杂度及开发时间及运行耗时增高
        做法
            1.只调用 当前类自身的方法
            2.只调用 函数参数传入的对象的方法
            3.只调用 当前方法实例化的对象的方法
            4.只调用 当前类自身的实例属性的方法
            5.不要 通过 其他类的 getField 方法获取 它的实例属性，而是应该通过 getSomeValue 来直接获取 它的实例属性的值

命令模式核心: 统一与整合一群外部类行为 [写 n 个外部类的命令接口实现类] [以 implement 为体系] [1 标准 - n 实现 单一接口体系]
装饰者模式核心: 在原有能力上进行二次扩展，不改变已有函数签名但增加新的处理特性 [以 extends 为体系] [单一接口体系]
适配器模式核心: 在原有能力上整合适配目标要求(行为/类) [可 extends 可 implement] [两个接口体系进行适配]
外观模式核心: 提供复杂系统成员的一个简化接口 [写 1 个组合类] [就是个封装 & 解耦使用者与复杂系统] [与适配器、命令模式 意图不同] [n 实现 - 1 统一组合 单一接口体系]
    外观模式 还可以 通过 命令模式的宏指令实现 [比较简单 没有什么新的东西就不再单独开目录进行代码赘述]
所有的原则 都应该在有帮助的时候 遵守，所有设计都需要折中取舍