实质: CommandPattern 简化版，核心是相同的
    均是 implement 某个接口 + 内置本体实例变量

使用场景: 将一个类的接口 转换为 客户期望的另一个接口，适配器/中间层让 两个接口不同的类 可以合作无间

注意
    1.现实远远复杂，不限制 只 包装一个 本体
    2.现实远远复杂，可以使用 extends 替换 implement 这个情况下 我们叫他 (继承)类适配器，反之叫做 (组合)对象适配器
        二者各有优劣，看成本情况进行综合考虑

与命令模式异同
    同: 使用/调用者(Invoker) 与 被适配者(本体) 相互解耦 通过 中间/适配层
    异: Command 接口是 新的统一性的非已有的，而 这里的适配器 implement 的接口 是 已有目标的
        实质上就是 面向的场景不同 实现的 接口 具有不同的含义

命令模式核心: 统一与整合一群外部类行为 [以 implement 为体系] [1-n 接口体系]
装饰者模式核心: 在原有能力上进行二次扩展，不改变已有函数签名但增加新的处理特性 [以 extends 为体系] [只有一个接口体系]
适配器模式核心: 在原有能力上整合适配目标要求(行为/类) [可 extends 可 implement] [两个接口体系进行适配]