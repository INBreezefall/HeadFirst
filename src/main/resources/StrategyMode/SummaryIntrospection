工具箱总结
    基础
        封装、抽象、继承、多态
    原则
        抽取隔离(封装)变化与不变代码
        多用组成，少用继承
        针对接口编程，不针对实现编程(只调用接口方法，不管实现)
    模式
        策略模式: 定义算法族，以接口作为约束，分别实现并可相互替换
        优点: 将算法的变化 独立于 算法的客户(主体类) / 将实现变化的函数独立于其所在抽象类

    注:
        设计模式不是代码，而是一种通用解决方案，是被发现的，而非发明的
        大多数模式都着眼于软件变化的主题，且都允许系统局部改变独立于其他部分
        设计模式令开发者之间最大程度简化经验交流信息，实现高价值密度信息交流

    将变化与不变抽离出来 在 策略模式中 体现
        1.子类行为的具体实现 是变化的
            行为A 包含 实现1 实现2 实现3 ...

        不好的设计：
            当 1 发生变化的时候 如果使用 继承关系 则 不适用 父类已实现方法的 子类s 则必须覆写
            当 1 发生变化的时候 如果将 实现1、实现2、实现3... 分别抽象为一个个 接口1 2 3 适用的子类 实现 对应接口
                这会导致 有 100个 子类 就要 写 100个实现，其中可能存在大量重复代码
                    [但Java8 接口 default可以解决重复代码问题，但不能剥离 变化部分 从 子类中]

        好的设计：
            当 1 发生变化的时候 新增 子类行为 m 时，子类不需要覆写，只需要 新增 行为A抽象接口 的 实现类 m
            在 新增子类构造器中 / set 将 行为A接口实现类 放入即可 [将 行为A 实现变化 剥离 子类及其抽象父类]

