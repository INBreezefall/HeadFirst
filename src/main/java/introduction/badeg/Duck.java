package introduction.badeg;

public abstract class Duck {
    public void quack() {}

    public void swim() {}

    public void display() {}

    // 在抽象类中添加 方法 会令所有子类 继承 ——> 包含不应拥有 此方法 子类
    // 抽象类中的方法 理应是 全部子类的通用方法，如果不是，则会导致 子类 无用 空 覆写
    // 这里出现的问题本质是 继承条件下的 子类维护 与 代码复用 的矛盾
    // 解决方案1：接口，让拥有 特定行为 子类 自己去 实现 特定行为接口 ——> 但这样会令代码无法复用 有多少个子类就有多少个实现代码
    //
    // 问题归零 ——>
    // 设计原则 1 分开变化与不变化的代码
    //     找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起
    //     换句话说，把会变化的部分取出来并封装起来，以便以后可以轻易地改动或扩展此部分，而不影响其他不需要变化的部分
    // 设计原则 2 针对接口编程，而不是针对实现编程
    //
    // 更佳方案: 将 变化的子类行为 不再作为 超类 函数
    //
    public void fly() {}
}