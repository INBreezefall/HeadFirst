package StrategyMode.badeg;

@SuppressWarnings("unused")
public abstract class Duck {
    public void quack() {}

    public void swim() {}

    public void display() {}

/*
     在抽象类中添加 方法 会令所有子类 继承 ——> 包含不应拥有 此方法 子类
     抽象类中的方法 理应是 全部子类的通用方法，如果不是，则会导致 子类 无用 空 覆写
     这里出现的问题本质是 继承条件下的 子类维护 与 代码复用 的矛盾
     解决方案1：接口，让拥有 特定行为 子类 自己去 实现 特定行为接口 ——> 但这样会令代码无法复用 有多少个子类就有多少个实现代码

     问题归零 ——>
         设计原则 1 分开变化与不变化的代码
             找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起
             换句话说，把会变化的部分取出来并封装起来，以便以后可以轻易地改动或扩展此部分，而不影响其他不需要变化的部分
         设计原则 2 针对接口编程，而不是针对实现编程
             抽像类 可以认为是 具有 多个抽象行为 + 多个抽象属性 的耦合体 代表一类 事物/存在
             其中，抽象类继承中存在 抽象行为的 实现 的 耦合问题
                如果在 抽象类中 实现 行为，那么在不适用的子类中 都将需要进行覆写
                如果不在 抽象类中 实现 行为，那么子类中 就会 存在重复代码
             针对上述 部分继承 需求，就提出了上面的原则
             将可能变化的 抽象行为 从 抽象类中 提出，成为 接口 Interface，并将接口 实现 独立于 抽象类
             从而 既不需要 子类实现写重复代码 也不需要对特殊子类进行方法实现覆写
         设计原则 3 多用组合，少用继承
             不将

     更佳方案: 将 变化的子类行为 不再作为 超类 函数 实现，而是采用 接口编程 将 接口类 作为 超类的一个实例变量
        继承优点——重用实现代码，接口优点——更加细粒度的将行为实现分类，而非像继承一样一股脑的一口吞
        程序可以针对超类型(接口)编程，在运行时根据类的实现类调用实现类的行为，这称为 Java 多态

*/

    public void fly() {}
}